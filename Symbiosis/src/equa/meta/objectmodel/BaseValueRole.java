/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package equa.meta.objectmodel;

import java.util.Iterator;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.ManyToOne;
import javax.persistence.OneToOne;
import javax.persistence.Transient;

import equa.meta.ChangeNotAllowedException;
import equa.meta.MismatchException;
import equa.meta.requirements.RequirementModel;
import equa.meta.requirements.RuleRequirement;
import equa.meta.traceability.Category;
import equa.meta.traceability.ExternalInput;
import equa.meta.traceability.ModelElement;
import equa.project.ProjectRole;
import equa.util.Naming;

/**
 *
 * @author frankpeeters
 */
@Entity
public class BaseValueRole extends Role {

    private static final long serialVersionUID = 1L;
    @OneToOne(cascade = CascadeType.PERSIST, fetch = FetchType.EAGER)
    private BaseType bt;
    @Column
    private DefaultValueConstraint defaultValue;
    @ManyToOne(cascade = CascadeType.PERSIST, fetch = FetchType.EAGER)
    private RuleRequirement ruleAutoIncr;
    @Transient
    private transient BaseType toDisconnect;

    public BaseValueRole() {
    }

    public BaseValueRole(BaseType bt, FactType parent) {
        super(parent);
        this.bt = bt;
        defaultValue = null;
        //      ruleDefaultValue = null;
        ruleAutoIncr = null;
        toDisconnect = null;
    }

    public void setAutoIncrement(boolean autoIncr) throws ChangeNotAllowedException {
        if (isAutoIncr() == autoIncr) {
            return;
        }

        if (autoIncr) {
//            if (!parent.isObjectType()){
//                throw new ChangeNotAllowedException(
//                        "auto increment only allowed in case of identifying role of object type");
//            
//            }
            if (!bt.equals(BaseType.NATURAL)) {
                throw new ChangeNotAllowedException(
                        "auto increment only allowed in case of natural number role");
            }
            if (getDefaultValue() != null) {
                defaultValue.remove();
            }

            ObjectModel om = (ObjectModel) getParent().getParent();
            RequirementModel rm = om.getProject().getRequirementModel();
            ProjectRole projectRole = om.getProject().getCurrentUser();

            ruleAutoIncr = rm.addRuleRequirement(getParent().getCategory(),
                    "The value of " + getRoleName() + " in <" + getParent().getName()
                    + "> is generated by auto increment",
                    new ExternalInput("", projectRole));

        } else {
            ruleAutoIncr.remove();
            ruleAutoIncr = null;
        }
        //publisher.inform(this, "autoincr", null, isAutoIncr());

    }

    @Override
    public boolean isAutoIncr() {
        return ruleAutoIncr != null;
    }

    @Override
    public String getDefaultValue() {
        if (defaultValue == null) {
            return null;
        } else {
            return defaultValue.getValue();
        }
    }

    public void removeDefaultValue() {
        if (defaultValue != null) {
            try {
                defaultValue.remove();
            } catch (ChangeNotAllowedException ex) {
                Logger.getLogger(BaseValueRole.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }

    public void setDefaultValue(String value) throws MismatchException, ChangeNotAllowedException {
        if (defaultValue != null && defaultValue.getValue().equalsIgnoreCase(value)) {
            return;
        }
        if (isAutoIncr()) {
            throw new ChangeNotAllowedException("Default value cannot be combined with auto increment");
        }
        bt.checkSyntaxis(value);

        String rolename = getRoleName();
        if (rolename.isEmpty()) {
            rolename = Naming.withoutCapital(bt.getName());
        }

        if (this.defaultValue != null) {
            this.defaultValue.remove();
        }

//        ruleDefaultValue = rm.addRuleRequirement(getParent().getCategory(),
//                defaultValue + " is the default value of <" + rolename
//                + "> in " + getParent().getFactTypeString(),
//                new ExternalInput("", projectRole));
        ObjectModel om = (ObjectModel) getParent().getParent();
        RequirementModel rm = om.getProject().getRequirementModel();
        ProjectRole projectRole = om.getProject().getCurrentUser();
        Category cat = getParent().getCategory();

        RuleRequirement rule = rm.addRuleRequirement(cat,
                value + " is the default value of <" + rolename
                + "> in " + getParent().getFactTypeString(),
                new ExternalInput("", projectRole));

        this.defaultValue = new DefaultValueConstraint(this, value, rule);
    }

    void deleteDefaultValue() {
        if (defaultValue != null) {
            defaultValue = null;
        }
    }

    @Override
    public BaseType getSubstitutionType() {
        return bt;
    }

    @Override
    public boolean isNavigable() {
        return false;
    }

    @Override
    public void setNavigable(boolean navigable) {
    }

    @Override
    public boolean isAbstract() {
        return false;
    }

    @Override
    SubstitutionType disconnect() {
        toDisconnect = bt;
        bt = null;
        return toDisconnect;
    }

    @Override
    void reconnect() {
        bt = toDisconnect;
        toDisconnect = null;
    }

    @Override
    public boolean isComposition() {
        return false;
    }

    @Override
    public boolean setComposition(boolean composition) {
        return false;
    }

    @Override
    public String getConstraintString() {
        Iterator<StaticConstraint> it = constraints();
        StringBuilder sb = new StringBuilder();
        while (it.hasNext()) {
            sb.append(it.next().getDescription()).append(" ");
        }
        if (isQualifier()) {
            if (isSeqNr()) {
                sb.append("seq ");
            } else {
                sb.append("map ");
            }
        }
        if (isHidden()) {
            sb.append("hid ");
        }
        if (hasDefaultValue()) {
            sb.append(defaultValue.getValue());
        }
        if (isAutoIncr()) {
            sb.append("incr");
        }

        return sb.toString().trim();

    }

    @Override
    public boolean isSettable() {
        return false;
    }

    @Override
    public boolean isAdjustable() {
        return false;
    }

    @Override
    public boolean isInsertable() {
        return false;
    }

    @Override
    public boolean isSeqNr() {
        return isQualifier() && bt.equals(BaseType.NATURAL);
    }

//    @Override
//    public void setSeqNr(boolean seqNr) {
//        if (bt.equals(BaseType.INTEGER) || bt.equals(BaseType.NATURAL)) {
//            this.seqNr = seqNr;
//        }
//    }
    @Override
    public boolean isAddable() {
        return false;
    }

    @Override
    public boolean isRemovable() {
        return false;
    }

    @Override
    public boolean hasDefaultValue() {
        return defaultValue != null;
    }

    @Override
    public void remove(ModelElement member) {
        // throw new UnsupportedOperationException("Not supported yet.");
    }

    public void setBaseType(BaseType bt) {
        if (bt != BaseType.NATURAL) {
            if (ruleAutoIncr != null) {
                try {
                    ruleAutoIncr.remove();
                } catch (ChangeNotAllowedException ex) {
                    Logger.getLogger(BaseValueRole.class.getName()).log(Level.SEVERE, null, ex);
                }
                ruleAutoIncr = null;
                publisher.inform(this, "autoincr", null, isAutoIncr());
            }

        }

        int roleNr = -1;
        List<Role> roles = getParent().roles;
        for (int i = 0; i < getParent().size(); i++) {
            if (roles.get(i) == this) {
                roleNr = i;
            }
        }
        getParent().getPopulation().changeBaseValueRole(roleNr, bt);
        this.bt = bt;

    }

    @Override
    public boolean isCandidateAutoIncr() {
        return bt.equals(BaseType.NATURAL);
    }

    @Override
    public boolean isCandidateAddable() {
        return false;
    }

    @Override
    public boolean isCandidateAdjustable() {
        return false;
    }

    @Override
    public boolean isCandidateSettable() {
        return false;
    }

    @Override
    public boolean isCandidateInsertable() {
        return false;
    }

    @Override
    public boolean isCandidateRemovable() {
        return false;
    }

    @Override
    public boolean isCandidateComposition() {
        return false;
    }

    @Override
    boolean isResponsibleForNonVT() {
        return false;
    }

    @Override
    public String getName() {
        return "role " + this.detectRoleName() + " of " + getParent().getName();
    }

    @Override
    public boolean equals(Object object) {
        return this == object;
    }

    @Override
    public void remove() throws ChangeNotAllowedException {
        super.remove();

        if (ruleAutoIncr != null) {
            ruleAutoIncr.remove();
            ruleAutoIncr = null;
            publisher.inform(this, "autoincr", null, isAutoIncr());
        }
        if (defaultValue != null) {
            defaultValue.remove();
            defaultValue = null;
        }
    }

    @Override
    public void expandSubstitutionType(ObjectType ot) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public boolean isCreational() {
        return false;
    }

    @Override
    public boolean isMappingRole() {
        return false;
    }

}
